{"text":"Java","children":[{"text":"基础语法","children":[{"text":"基本类型","children":[{"text":"int(4 byte)","children":[]},{"text":"short(2 bytes)","children":[]},{"text":"long(8 bytes)","children":[]},{"text":"byte(1 byte)","children":[]},{"text":"float(4 bytes)","children":[]},{"text":"double(8 bytes)","children":[]},{"text":"char","children":[]},{"text":"boolean","children":[]}]},{"text":"变量","children":[{"text":"关键字","children":[]},{"text":"大小写敏感","children":[]}]},{"text":"常量","children":[{"text":"final","children":[]}]},{"text":"运算符","children":[]},{"text":"enum","children":[]},{"text":"String","children":[{"text":"不可变","children":[]},{"text":"equals","children":[]},{"text":"indexOf()","children":[]},{"text":"length()","children":[]},{"text":"substring()","children":[]}]},{"text":"控制流程","children":[{"text":"if else","children":[]},{"text":"for","children":[]},{"text":"switch","children":[]},{"text":"try catch","children":[]},{"text":"assert","children":[]}]},{"text":"数组","children":[{"text":"int[] a;","children":[]},{"text":"for(variable: collection) statement","children":[]},{"text":"Arrays.copyOf","children":[]},{"text":"Arrays.sort","children":[]}]},{"text":"static","children":[{"text":"是类本身的属性, 而不是实例的属性","children":[]},{"text":"静态方法只能使用静态属性和方法","children":[]},{"text":"可以被继承, 但不能被重写","children":[]},{"text":"常修饰工厂方法","children":[]},{"text":"静态代码块会在类被加载是执行一次","children":[]}]},{"text":"final","children":[{"text":"属性不能被修改","children":[]},{"text":"方法不能被重写","children":[]},{"text":"类不能被继承","children":[]}]},{"text":"lambda","children":[{"text":"闭包","children":[]},{"text":"(String first, String second) -> first.length() - second.length()","children":[]},{"text":"() -> {}","children":[]},{"text":"event -> {}","children":[]},{"text":"System.out::println","children":[]},{"text":"Person::new","children":[]},{"text":"表达式中捕获的变量必须是最终变量","children":[]},{"text":"this为创建lambda表达式的方法的this","children":[]}]}]},{"text":"面向对象","children":[{"text":"核心特性","children":[{"text":"封装","children":[{"text":"访问控制符","children":[{"text":"private","children":[]},{"text":"default","children":[]},{"text":"protected","children":[]},{"text":"public","children":[]}]}]},{"text":"继承","children":[{"text":"单继承","children":[]},{"text":"final阻止继承","children":[]}]},{"text":"多态","children":[{"text":"类的多态(继承)","children":[]},{"text":"方法的多态(重写, 重载)","children":[]}]}]},{"text":"接口","children":[{"text":"属性为public static final","children":[]},{"text":"方法为public abstract","children":[]},{"text":"静态方法","children":[]},{"text":"默认方法","children":[]}]},{"text":"抽象类","children":[{"text":"只有抽象类能有抽象方法","children":[]},{"text":"为子类提供通用的逻辑","children":[]}]},{"text":"类","children":[{"text":"类之间的关系","children":[{"text":"依赖(uses-a)","children":[]},{"text":"聚合(has-a)","children":[]},{"text":"继承(is-a)","children":[]}]},{"text":"构造器","children":[{"text":"调用父类构造方法super()","children":[]}]},{"text":"初始化块","children":[{"text":"实例化时执行","children":[]}]},{"text":"方法","children":[{"text":"参数按值调用","children":[]},{"text":"变参","children":[]},{"text":"调用父类方法super.method()","children":[]}]},{"text":"特殊类","children":[{"text":"超类Object","children":[]},{"text":"Integer\\Long\\Fload\\Void\\Boolean...","children":[{"text":"自动装箱","children":[]}]},{"text":"枚举","children":[{"text":"直接用==比较","children":[]}]},{"text":"Class类","children":[]}]}]},{"text":"内部类","children":[{"text":"outer可访问外围私有对象","children":[]}]}]},{"text":"核心API","children":[{"text":"String","children":[]},{"text":"集合","children":[]},{"text":"日期时间","children":[]},{"text":"数学","children":[]},{"text":"IO流","children":[]},{"text":"异常","children":[{"text":"Throwable","children":[{"text":"Error(checked)","children":[]},{"text":"Exception","children":[{"text":"RuntimeException(checked)","children":[]}]}]}]},{"text":"文件操作","children":[]},{"text":"并发编程","children":[{"text":"线程的创建","children":[{"text":"Thread::start调用native start0创建新线程\n新线程调用run方法\nrun方法被重写(1)\n或run方法调用target::run(Runnable::run)(2)","children":[]},{"text":"(1)继承Thread类，重写run方法","children":[{"text":"模板模式-start编写算法结构, run实现逻辑细节","children":[]}]},{"text":"(2)实现Runnable接口的run方法","children":[{"text":"策略模式-业务逻辑和线程控制解耦","children":[]}]}]},{"text":"线程的状态","children":[{"text":"NEW","children":[{"text":"线程被构建，尚未调用start方法","children":[]}]},{"text":"RUNNABLE","children":[{"text":"包括就绪和运行中两种状态","children":[]}]},{"text":"BLOCKED","children":[{"text":"阻塞于锁","children":[]}]},{"text":"WAITING","children":[{"text":"等待其他线程唤醒或中断","children":[]}]},{"text":"TIME_WAITING","children":[{"text":"超时等待，一定时间后自行返回","children":[]}]},{"text":"TERMINATED","children":[{"text":"终止状态","children":[]}]}]},{"text":"线程的操作","children":[{"text":"interrupted","children":[{"text":"public void interrupt()","children":[{"text":"线程A调用线程B的该方法创建interrupted标志位\n线程B在WAITING或者TIME_WAITING状态时会抛出InterruptedException\n并清除interrupted标志位","children":[]}]},{"text":"public boolean isInterrupted()","children":[{"text":"判断是否有interrupted标志位","children":[]}]},{"text":"public static boolean interrupted()","children":[{"text":"判断是否有interrupted标志位并清除它","children":[]}]}]},{"text":"join","children":[{"text":"线程A调用线程B的join方法，表明线程A会处于\nWAITING或TIME-WAITING状态直到线程B结束","children":[]}]},{"text":"sleep","children":[{"text":"Thread静态方法，只是简单让出CPU，进入TIME-WAITING状态","children":[]}]},{"text":"wait","children":[{"text":"实例方法","children":[]},{"text":"只能在synchronized块中调用","children":[]},{"text":"会释放锁，线程进入WAITING状态","children":[]},{"text":"需要调用同一个锁对象的notify或者notifyAll唤醒","children":[]}]},{"text":"notify","children":[{"text":"唤醒一个调用过当前锁对象的wait方法的线程","children":[]},{"text":"并不会释放锁，即唤醒的线程仍然需要等待当前线程释放锁","children":[]}]},{"text":"notifyAll","children":[{"text":"唤醒所有调用过当前锁对象的wait方法的线程","children":[]},{"text":"并不会释放锁，即唤醒的线程仍然需要等待当前线程释放锁","children":[]}]},{"text":"yield","children":[{"text":"线程调用该方法即表明，我当前的任务不重要，\n调度器可以检查是否有其他更高优先级的线程在WAITING，\n如果有，即执行它并WAITING当前线程","children":[]}]}]},{"text":"线程安全","children":[{"text":"不安全的原因","children":[{"text":"主内存和工作内存数据不一致性","children":[{"text":"JMM","children":[{"text":"共享数据(实例域、静态域和数组)放在堆内存(主内存)中","children":[]},{"text":"每个线程有自己的工作内存","children":[]},{"text":"工作内存中有共享数据的副本","children":[]},{"text":"副本被改变会写入到主内存","children":[]}]}]},{"text":"重排序","children":[{"text":"1.编译器重排序","children":[]},{"text":"2.处理器重排序","children":[{"text":"指令级并行重排序","children":[]},{"text":"内存系统重排序","children":[]}]}]}]},{"text":"JMM的努力","children":[{"text":"向上，对程序员保证执行结果遵守happens-before原则","children":[]},{"text":"向下，约束编译器和处理器不能改变程序的执行结果(即单线程程序和正确同步的多线程程序)","children":[{"text":"程序顺序规则","children":[]},{"text":"监视器锁规则","children":[]},{"text":"volatile变量规则","children":[]},{"text":"传递性","children":[]},{"text":"start()规则","children":[]},{"text":"join()规则","children":[]},{"text":"程序中断规则","children":[]},{"text":"对象finalize规则","children":[]}]},{"text":"happens-before关系","children":[{"text":"保证正确同步的多线程程序的执行结果不被改变","children":[]}]},{"text":"(as-if-serial语义)","children":[{"text":"单线程内程序的执行结果不被改变","children":[]}]}]},{"text":"锁","children":[{"text":"原理","children":[{"text":"1.6之前(重量级锁)","children":[{"text":"每一个对象都可以当做锁","children":[]},{"text":"每个对象都有监视器(monitor)","children":[]},{"text":"访问加锁(synchronized)资源需要获取锁的监视器(monitor)","children":[]},{"text":"同一时刻只能有一个线程获取到监视器(monitor) - 排他性","children":[]},{"text":"得不到资源的线程会进入BLOCKED状态","children":[]}]},{"text":"1.6优化后","children":[{"text":"锁状态","children":[{"text":"无锁","children":[]},{"text":"偏向锁","children":[{"text":"没有其他线程竞争时，无需加锁解锁操作","children":[]},{"text":"原理","children":[{"text":"访问同步块时，检查锁对象头中是否是自己的线程ID","children":[]},{"text":"如果是，无需加锁即获得资源","children":[]},{"text":"如果不是，尝试CAS设置自己的线程ID","children":[]},{"text":"成功，则获得资源，锁不升级","children":[]},{"text":"失败，则挂起拥有锁的线程，锁升级为轻量级，\n恢复挂起线程开始轻量级竞争","children":[]}]}]},{"text":"轻量级锁","children":[{"text":"通过适量的自旋减少线程的挂起和唤醒","children":[]},{"text":"原理","children":[{"text":"尝试CAS替换Mark Word","children":[]},{"text":"成功，获得锁","children":[]},{"text":"失败，进入自旋(循环尝试获取锁)","children":[]},{"text":"自旋到适量程度仍无法得到锁，自旋失败，\n线程进入阻塞，锁升级为重量级","children":[]}]}]},{"text":"重量级锁","children":[{"text":"得不到锁的线程被挂起并放到相应的队列中，等待被唤醒","children":[]},{"text":"原理","children":[{"text":"尝试获得锁","children":[]},{"text":"失败，进入自旋","children":[]},{"text":"一定程度后再失败，放入相应队列，等待被唤醒","children":[]},{"text":"唤醒后再尝试，(...失败...自旋...挂起...唤醒...尝试...)","children":[]}]},{"text":"注意：当调用一个锁对象的wait或notify方法时，\n如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁","children":[]}]}]},{"text":"状态变化","children":[{"text":"随竞争情况升级","children":[]},{"text":"升级很容易发生","children":[]},{"text":"降级条件苛刻(只有在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁)","children":[]}]},{"text":"Java对象头","children":[{"text":"对象的锁状态存储在Java对象头中","children":[]},{"text":"组成","children":[{"text":"Mark Word(32/64bit)","children":[{"text":"29/61bit","children":[]},{"text":"1 bit 是否是偏向锁","children":[]},{"text":"2 bit 锁标志位","children":[]}]},{"text":"Class Metadata Address(32/64bit)","children":[]},{"text":"Array length(32/64bit)","children":[]}]}]}]}]},{"text":"分类","children":[{"text":"悲观锁","children":[{"text":"认为每次访问都有冲突，必须加锁","children":[]}]},{"text":"乐观锁","children":[{"text":"认为每次都没有冲突，不加锁","children":[]},{"text":"如果发生冲突，就通过使用CAS保证线程安全","children":[]},{"text":"所以乐观锁天生免疫死锁","children":[]}]},{"text":"读多写少用乐观锁，读少写多用悲观锁","children":[]}]},{"text":"CAS","children":[{"text":"Compare And Swap","children":[]},{"text":"值","children":[{"text":"V","children":[{"text":"要更新的变量","children":[]}]},{"text":"E","children":[{"text":"预期值(旧值)","children":[]}]},{"text":"N","children":[{"text":"新值","children":[]}]}]},{"text":"过程","children":[{"text":"检查变量V中的值是否等于E","children":[]},{"text":"等于，说明V的值没有发生变化，把N赋值给V","children":[]},{"text":"不等于，说明V的值发生了变化，此次CAS失败","children":[]}]},{"text":"三个问题","children":[{"text":"ABA问题","children":[{"text":"A变成B又变成A，CAS察觉不到变化","children":[]},{"text":"解决方法：加上版本号，或者时间戳","children":[]},{"text":"比如使用atomic包中的AtomicStampedReference类","children":[]}]},{"text":"循环时间长开销大","children":[{"text":"CAS失败后大多需要自旋，自旋长时间不成功，占用大量CPU资源","children":[]},{"text":"解决思路是让JVM支持处理器提供的pause指令","children":[]}]},{"text":"只能保证一个共享变量的原子操作","children":[{"text":"解决方法就是1. 把多个变量放到一个对象里，然后使用AtomicReference","children":[]},{"text":"2. 使用锁","children":[]}]}]}]}]},{"text":"synchronized","link":"http://concurrent.redspider.group/article/02/9.html","children":[{"text":"作用：为方法或代码块加锁","children":[]},{"text":"synchronized使用","children":[{"text":"静态方法","children":[]},{"text":"实例方法","children":[]},{"text":"代码块","children":[]}]}]},{"text":"volatile","children":[{"text":"作用是保证内存可见性","children":[{"text":"即一个线程修改volatile变量后，\n另一个线程立即可见","children":[]}]},{"text":"程序员角度","children":[{"text":"JMM保证的happens-before原则之一","children":[{"text":"volatile变量规则","children":[{"text":"对一个volatile域的写，happens-before于任意后续对这个volatile域的读","children":[]}]}]},{"text":"内存语义","children":[{"text":"volatile变量的改变导致工作内存立即写入到主内存","children":[]},{"text":"并且其他线程的工作内存立即失效，需要同步主内存","children":[]}]}]},{"text":"JMM角度","children":[{"text":"通过内存屏障限制处理器重排序","children":[]}]},{"text":"用途","children":[{"text":"可以理解为volatile变量是一个“轻量级”的锁","children":[]},{"text":"只保证对一个变量的读写具有原子性","children":[]},{"text":"性能比锁好","children":[]},{"text":"实例：单例模式 - 双重锁检查实现方式","children":[]}]}]}]}]},{"text":"网络编程","children":[]},{"text":"泛型","children":[]},{"text":"注解","children":[]},{"text":"枚举","children":[]}]},{"text":"JVM","children":[{"text":"类的加载","children":[{"text":"ClassLoader","children":[{"text":"懒加载","children":[]},{"text":"1.加载","children":[]},{"text":"2.连接","children":[{"text":"赋予变量初始值-类型默认值","children":[]}]},{"text":"3.初始化","children":[{"text":"赋予变量正确值","children":[]}]}]},{"text":"特点","children":[{"text":"父委托：先让父加载器尝试","children":[]}]},{"text":"1.Bootstrap","children":[{"text":"加载核心类库，比如java.lang","children":[]}]},{"text":"2.Ext","children":[{"text":"加载jre/lb/ext中的类","children":[]}]},{"text":"3.Application","children":[{"text":"加载classpath中的类","children":[]}]}]}]},{"text":"框架","children":[]},{"text":"设计原则","children":[]},{"text":"设计模式","children":[]}]}